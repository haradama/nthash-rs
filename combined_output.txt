File: src/util.rs
//! Miscellaneous helpers shared across all ntHash variants.
//!
//! This module provides two small yet critical building blocks used by
//! every ntHash implementation (`NtHash`, `SeedNtHash`, `BlindNtHash`, etc.):
//!
//! - **`canonical`** — combine forward and reverse‐complement hashes into a
//!   strand‐independent value by wrapping addition.
//! - **`extend_hashes`** — generate a sequence of "extra" hash values from
//!   one canonical base hash, matching the C++ reference’s multiplicative
//!   mixing and shift scheme.
//!
//! These functions are marked `#[inline]` for zero‐overhead calls in hot paths,
//! and the code is dependency‐free (only `core`/`std`), so it can be used
//! in no‐std contexts if needed.

use crate::constants::{MULTISEED, MULTISHIFT};

/// Combine forward and reverse‐complement strand hashes into a single
/// *canonical* k‑mer hash (strand‐independent).
///
/// The original ntHash definition simply **adds** the two 64‑bit words with
/// wrapping arithmetic to remain well‐defined on overflow.
///
/// # Examples
///
/// ```
/// # use nthash::util::canonical;
/// let fwd = 0xFFFF_FFFF_FFFF_FFFF;
/// let rev = 1;
/// // wraps around to 0
/// assert_eq!(canonical(fwd, rev), 0);
/// ```
#[inline(always)]
pub const fn canonical(fwd: u64, rev: u64) -> u64 {
    fwd.wrapping_add(rev)
}

/// Expand a single canonical hash into a user‐provided slice of additional
/// hash values.
///
/// This implements the same scheme as the C++ ntHash reference:
/// each extra hash `h_i` (for `i ≥ 1`) is computed as:
///
/// ```text
///   mix   = (i as u64) ^ (k as u64 * MULTISEED)
///   h_i   = base.wrapping_mul(mix)
///   h_i  ^= h_i >> MULTISHIFT
/// ```
///
/// - `fwd`, `rev`  — forward and reverse‐complement strand hashes.
/// - `k`           — k‑mer span or seed weight, used in the mixing step.
/// - `hashes`      — output slice; the length determines how many values
///                   (including the canonical hash at index 0) are generated.
///
/// If `hashes` is empty, this function returns immediately, avoiding any
/// unnecessary branching in callers.
///
/// # Examples
///
/// ```
/// # use nthash::util::extend_hashes;
/// let mut out = [0u64; 4];
/// extend_hashes(0x1234, 0x5678, 5, &mut out);
/// assert_eq!(out[0], 0x1234u64.wrapping_add(0x5678));
/// // subsequent elements are nonzero mixes
/// assert!(out[1] != out[0]);
/// ```
#[inline]
pub fn extend_hashes(fwd: u64, rev: u64, k: u32, hashes: &mut [u64]) {
    if hashes.is_empty() {
        return;
    }

    // Base (canonical) hash at index 0
    let base = canonical(fwd, rev);
    hashes[0] = base;

    // Compute extra hashes for i = 1 .. len−1
    for (i, slot) in hashes.iter_mut().enumerate().skip(1) {
        // identical to C++ reference: h_i = h_0 * (i ^ (k * MULTISEED))
        let mix = (i as u64) ^ (k as u64).wrapping_mul(MULTISEED);
        let mut t = base.wrapping_mul(mix);
        // final avalanche shift
        t ^= t >> MULTISHIFT;
        *slot = t;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn canonical_wraps_on_overflow() {
        let max = u64::MAX;
        assert_eq!(canonical(max, 1), 0);
    }

    #[test]
    fn extend_zero_length_slice() {
        let mut out: [u64; 0] = [];
        extend_hashes(123, 456, 7, &mut out);
        // no panic, no change
    }

    #[test]
    fn extend_matches_cpp_reference() {
        const F: u64 = 0x1234_5678_9ABC_DEF0;
        const R: u64 = 0x0FED_CBA9_8765_4321;
        const K: u32 = 21;
        let mut v = [0u64; 8];
        extend_hashes(F, R, K, &mut v);
        let base = F.wrapping_add(R);
        for i in 0..v.len() {
            let expected = if i == 0 {
                base
            } else {
                let mut t = base.wrapping_mul((i as u64) ^ (K as u64).wrapping_mul(MULTISEED));
                t ^= t >> MULTISHIFT;
                t
            };
            assert_eq!(v[i], expected);
        }
    }
}



File: src/constants.rs
#![allow(clippy::unreadable_literal)]
//! Central **lookup tables & numeric constants** shared by every ntHash variant
//! in this crate (`NtHash`, `BlindNtHash`, `SeedNtHash`, …).
//!
//! This module is a byte‐for‐byte port of the official C++ reference
//! (commit `b77f7f6`, ntHash v2), reformatted for idiomatic Rust.  All tables
//! and constants were generated by the original authors and **must not be
//! modified** unless you are intentionally changing the hash function.
//!
//! The contents include:
//! - Random 64‑bit seeds for each nucleotide (A, C, G, T, N).  
//! - Constants governing hash extension (`MULTISEED`, `MULTISHIFT`).  
//! - Split‑rotate lookup tables for 31‑ and 33‑bit halves.  
//! - Pre‑hashed dimer/trimer/tetramer tables.  
//! - ASCII → nucleotide index and reverse‑complement index tables.  
//!
//! These tables drive all of ntHash’s core operations without runtime
//! branching.

/// Number of ASCII codes.
pub const ASCII_SIZE: usize = 256;

//==============================================================================
// 64‑bit random seeds for each base.
//==============================================================================

/// Seed for Adenine (A/a).
pub const SEED_A: u64 = 0x3c8bfbb3_95c6_0474;
/// Seed for Cytosine (C/c).
pub const SEED_C: u64 = 0x3193c185_62a0_2b4c;
/// Seed for Guanine (G/g).
pub const SEED_G: u64 = 0x20323ed0_8257_2324;
/// Seed for Thymine (T/t).
pub const SEED_T: u64 = 0x295549f5_4be2_4456;
/// Ambiguous base (N or any other) → contributes zero to every hash.
pub const SEED_N: u64 = 0;

/// ASCII XOR offset to convert a base to its complement in ASCII:
/// (`A ↔ T`, `C ↔ G`).
pub const CP_OFF: u8 = 0x07;

//==============================================================================
// Parameters for hash extension (derive multiple hashes per k‑mer).
//==============================================================================

/// Right‑shift amount applied after multiplicative mix.
pub const MULTISHIFT: u32 = 27;
/// Constant multiplier used in extra‑hash mixing.
pub const MULTISEED:  u64 = 0x90b45d39_fb6d_a1fa;

//==============================================================================
// Split‑rotate tables for 31‑bit and 33‑bit halves.
//==============================================================================
//
// For each nucleotide (A/C/G/T/N), we store two precomputed tables:
// - MS_TAB_33R: 33‑bit right‑half rotations (indices 0–32).
// - MS_TAB_31L: 31‑bit left‑half rotations (indices 0–30).
//
// The ASCII arrays below simply point into those five real tables.

/// 33‑bit right‐half split‐rotate for A/a.
pub const A33R: [u64; 33] = [
    0x195c60474, 0x12b8c08e9, 0x571811d3,  0xae3023a6,  0x15c60474c,
    0xb8c08e99,  0x171811d32, 0xe3023a65,  0x1c60474ca, 0x18c08e995,
    0x11811d32b, 0x3023a657,  0x60474cae,  0xc08e995c,  0x1811d32b8,
    0x1023a6571, 0x474cae3,   0x8e995c6,   0x11d32b8c,  0x23a65718,
    0x474cae30,  0x8e995c60,  0x11d32b8c0, 0x3a657181,  0x74cae302,
    0xe995c604,  0x1d32b8c08, 0x1a6571811, 0x14cae3023, 0x995c6047,
    0x132b8c08e, 0x6571811d,  0xcae3023a,
];
/// 31‑bit left‑half split‑rotate for A/a.
pub const A31L: [u64; 31] = [
    0x3c8bfbb2_00000000, 0x7917f764_00000000, 0xf22feec8_00000000,
    0xe45fdd92_00000000, 0xc8bfbb26_00000000, 0x917f764e_00000000,
    0x22feec9e_00000000, 0x45fdd93c_00000000, 0x8bfbb278_00000000,
    0x17f764f2_00000000, 0x2feec9e4_00000000, 0x5fdd93c8_00000000,
    0xbfbb2790_00000000, 0x7f764f22_00000000, 0xfeec9e44_00000000,
    0xfdd93c8a_00000000, 0xfbb27916_00000000, 0xf764f22e_00000000,
    0xeec9e45e_00000000, 0xdd93c8be_00000000, 0xbb27917e_00000000,
    0x764f22fe_00000000, 0xec9e45fc_00000000, 0xd93c8bfa_00000000,
    0xb27917f6_00000000, 0x64f22fee_00000000, 0xc9e45fdc_00000000,
    0x93c8bfba_00000000, 0x27917f76_00000000, 0x4f22feec_00000000,
    0x9e45fdd8_00000000,
];

/// 33‑bit right‐half split‑rotate for C/c.
pub const C33R: [u64; 33] = [
    0x162a02b4c, 0xc5405699,  0x18a80ad32, 0x115015a65, 0x2a02b4cb,
    0x54056996,  0xa80ad32c, 0x15015a658, 0xa02b4cb1,  0x140569962,
    0x80ad32c5,  0x1015a658a,0x2b4cb15,   0x569962a,   0xad32c54,
    0x15a658a8,  0x2b4cb150, 0x569962a0,  0xad32c540,  0x15a658a80,
    0xb4cb1501,  0x169962a02,0xd32c5405,  0x1a658a80a, 0x14cb15015,
    0x9962a02b,  0x132c54056,0x658a80ad,  0xcb15015a,  0x1962a02b4,
    0x12c540569, 0x58a80ad3, 0xb15015a6,
];
/// 31‑bit left‑half split‑rotate for C/c.
pub const C31L: [u64; 31] = [
    0x3193c184_00000000, 0x63278308_00000000, 0xc64f0610_00000000,
    0x8c9e0c22_00000000, 0x193c1846_00000000, 0x3278308c_00000000,
    0x64f06118_00000000, 0xc9e0c230_00000000, 0x93c18462_00000000,
    0x278308c6_00000000, 0x4f06118c_00000000, 0x9e0c2318_00000000,
    0x3c184632_00000000, 0x78308c64_00000000, 0xf06118c8_00000000,
    0xe0c23192_00000000, 0xc1846326_00000000, 0x8308c64e_00000000,
    0x6118c9e0_00000000, 0xc23193c0_00000000, 0x18463278_00000000,
    0x308c64f0_00000000, 0x6118c9e0_00000000, 0xc23193c0_00000000,
    0x84632782_00000000, 0x8c64f060_00000000, 0x118c9e0c_00000000,
    0x23193c18_00000000, 0x46327830_00000000, 0x8c64f060_00000000,
    0x18c9e0c2_00000000,
];

/// 33‑bit right‑half split‑rotate for G/g.
pub const G33R: [u64; 33] = [
    0x082572324, 0x104ae4648, 0x095c8c91, 0x12b91922, 0x25723244,
    0x4ae46488,  0x95c8c910,  0x12b919220,0x57232441, 0xae464882,
    0x15c8c9104, 0xb9192209,  0x172324412,0xe4648825, 0x1c8c9104a,
    0x191922095, 0x12324412b,0x46488257,  0x8c9104ae, 0x11922095c,
    0x324412b9,  0x64882572,  0xc9104ae4, 0x1922095c8,0x124412b91,
    0x48825723,  0x9104ae46,  0x122095c8c,0x4412b919, 0x88257232,
    0x1104ae464, 0x2095c8c9,  0x412b9192,
];
/// 31‑bit left‑half split‑rotate for G/g.
pub const G31L: [u64; 31] = [
    0x20323ed0_00000000, 0x40647da0_00000000, 0x80c8fb40_00000000,
    0x0191f682_00000000, 0x0323ed04_00000000, 0x0647da08_00000000,
    0x0c8fb410_00000000, 0x191f6820_00000000, 0x323ed040_00000000,
    0x647da080_00000000, 0xc8fb4100_00000000, 0x91f68202_00000000,
    0x23ed0406_00000000, 0x47da080c_00000000, 0x8fb41018_00000000,
    0x1f682032_00000000, 0x3ed04064_00000000, 0x7da080c8_00000000,
    0xfb410190_00000000, 0xf6820322_00000000, 0xed040646_00000000,
    0xda080c8e_00000000, 0xb410191e_00000000, 0x6820323e_00000000,
    0xd040647c_00000000, 0xa080c8fa_00000000, 0x410191f6_00000000,
    0x820323ec_00000000, 0x040647da_00000000, 0x080c8fb4_00000000,
    0x10191f68_00000000,
];

/// 33‑bit right‑half split‑rotate for T/t.
pub const T33R: [u64; 33] = [
    0x14be24456, 0x097c488ad,  0x12f89115a, 0x5f1222b5,  0xbe24456a,
    0x17c488ad4, 0x0f89115a9, 0x1f1222b52, 0x1e24456a5, 0x1c488ad4b,
    0x189115a97, 0x11222b52f, 0x024456a5f, 0x0488ad4be, 0x09115a97c,
    0x1222b52f8, 0x4456a5f1,  0x88ad4be2,  0x1115a97c4, 0x222b52f89,
    0x456a5f12,  0x8ad4be24,  0x115a97c48, 0x2b52f891,  0x56a5f122,
    0xad4be244,  0x15a97c488,0xb52f8911,  0x16a5f1222,0xd4be2445,
    0x1a97c488a, 0x152f89115,0xa5f1222b,
];
/// 31‑bit left‑half split‑rotate for T/t.
pub const T31L: [u64; 31] = [
    0x295549f4_00000000, 0x52aa93e8_00000000, 0xa55527d0_00000000,
    0x4aaa4fa2_00000000, 0x95549f44_00000000, 0x2aa93e8a_00000000,
    0x55527d14_00000000, 0xaaa4fa28_00000000, 0x5549f452_00000000,
    0xaa93e8a4_00000000, 0x5527d14a_00000000, 0xaa4fa294_00000000,
    0x549f452a_00000000, 0xa93e8a54_00000000, 0x527d14aa_00000000,
    0xa4fa2954_00000000, 0x49f452aa_00000000, 0x93e8a554_00000000,
    0x27d14aaa_00000000, 0x4fa29554_00000000, 0x9f452aa8_00000000,
    0x3e8a5552_00000000, 0x7d14aaa4_00000000, 0xfa295548_00000000,
    0xf452aa92_00000000, 0xe8a55526_00000000, 0xd14aaa4e_00000000,
    0xa295549e_00000000, 0x452aa93e_00000000, 0x8a55527c_00000000,
    0x14aaa4fa_00000000,
];

/// Default tables of SEED_N for any invalid ASCII code.
pub const N33R: [u64; 33] = [SEED_N; 33];
pub const N31L: [u64; 31] = [SEED_N; 31];

//==============================================================================
// Build ASCII‐indexed split‑rotate tables via const fns.
//==============================================================================

/// Build the 31‑bit rotation table array for all ASCII codes.
const fn build_tab31() -> [&'static [u64; 31]; ASCII_SIZE] {
    let mut t = [&N31L; ASCII_SIZE];
    // Map ASCII A/a, C/c, G/g, T/t to their tables
    t[b'A' as usize] = &A31L; t[b'a' as usize] = &A31L;
    t[b'C' as usize] = &C31L; t[b'c' as usize] = &C31L;
    t[b'G' as usize] = &G31L; t[b'g' as usize] = &G31L;
    t[b'T' as usize] = &T31L; t[b't' as usize] = &T31L;
    // Also populate entries for (char & CP_OFF)
    t[1] = &T31L; // 'A' & 7 = 1 → T
    t[3] = &G31L; // 'C' & 7 = 3 → G
    t[7] = &C31L; // 'G' & 7 = 7 → C
    t[4] = &A31L; // 'T' & 7 = 4 → A
    t
}
/// Final 31‑bit split‑rotate lookup table.
pub const MS_TAB_31L: [&'static [u64; 31]; ASCII_SIZE] = build_tab31();

/// Build the 33‑bit rotation table array for all ASCII codes.
const fn build_tab33() -> [&'static [u64; 33]; ASCII_SIZE] {
    let mut t = [&N33R; ASCII_SIZE];
    t[b'A' as usize] = &A33R; t[b'a' as usize] = &A33R;
    t[b'C' as usize] = &C33R; t[b'c' as usize] = &C33R;
    t[b'G' as usize] = &G33R; t[b'g' as usize] = &G33R;
    t[b'T' as usize] = &T33R; t[b't' as usize] = &T33R;
    t[1] = &T33R; // 'A' & 7 = 1 → T
    t[3] = &G33R; // 'C' & 7 = 3 → G
    t[7] = &C33R; // 'G' & 7 = 7 → C
    t[4] = &A33R; // 'T' & 7 = 4 → A
    t
}
/// Final 33‑bit split‑rotate lookup table.
pub const MS_TAB_33R: [&'static [u64; 33]; ASCII_SIZE] = build_tab33();

//==============================================================================
// Pre‑hashed tables for small k‑mers (2‑,3‑,4‑mers).
//==============================================================================

/// Precomputed random hashes for all dimers (size 2).
pub const DIMER_TAB: [u64; 16] = [
    5015898201438948509, 5225361804584821669, 6423762225589857229,
    5783394398799547583, 6894017875502584557, 5959461383092338133,
    4833978511655400893, 5364573296520205007, 9002561594443973180,
    8212239310050454788, 6941810030513055084, 7579897184553533982,
    7935738758488558809, 7149836515649299425, 8257540373175577481,
    8935100007508790523,
];

/// Precomputed random hashes for all trimers (size 3).
pub const TRIMER_TAB: [u64; 64] = [
    13237172352163388750, 13451082378889146998, 12324706752351386142,
    11704099346423635308, 12503002411303846718, 11573033083854154758,
    12770611021816489070, 13284814289517544220, 10286336837755622383,
    9500434588327378135,  10554658215321236671, 11177611689138066381,
    11245073286936829194, 10454751004568891954, 9274956656780491354,
    9930495270120774952,  9498947889754972591,  10289371588586147479,
    11487222103436658431, 10812501148518244749, 11088845979783725023,
    10735249574334615783, 9609199230360475791,  10105458452942995453,
    13447889238169808654, 13238535845420384310, 11968673763542288478,
    12645600078955589420, 12136759312206930411, 11922809957208297171,
    13031072242070652603, 13668666814620918217, 14219262150204358668,
    14433136993975185204, 15703263506252408668, 15026899868095529006,
    16097136083696541308, 15167201938128040260, 14113514427211577644,
    14608043031429815902, 18169629015343943341, 17383691583363408277,
    16185576633819064829, 16859734366019948175, 17215452794964541512,
    16425095330967072624, 17460550829194815256, 18101973914136232042,
    16197524846324948423, 17136496960994620159, 18190301010467109527,
    17660752969549176293, 18084590689685816247, 17861669045228104847,
    16591430392433501415, 17233003275094786965, 15689030113991676774,
    15321980360070757470, 14196301091602199606, 14727918144983470916,
    14660430141886012803, 14297932370981794491, 15550237822687034067,
    16044915679164358049,
];

/// Precomputed random hashes for all tetramers (size 4).
pub const TETRAMER_TAB: [u64; 256] = [
    6047278271377325800,  6842100033257738704,  5716751207778949560,
    5058261232784932554,  5322212292231585944,  4955210659836481440,
    6153481158060361672,  6630136099103187130,  7683058811908681801,
    7460089081761259377,  8513615477720831769,  9169618076073996395,
    8669810821731892908,  8451393064794886548,  7271235746105367036,
    7894785163577458318,  7461575445318369801,  7680024275870068017,
    8878022265940976985,  8237757801848291883,  9060296013225843833,
    8116780716040188737,  6991106539262573353,  7521593563379047515,
    6845292839028968616,  6045914992845185936,  4775672622745250808,
    5413871935584767114,  5490367161684853325,  4695435745326017909,
    5803018666222232861,  6480400171096490607,  2381043025085637546,
    3175899973157948562,  4445879008075678970,  3807116472585741192,
    4268108881087626714,  3901072061426881250,  2847008385469766282,
    3379366782720458232,  1763336001516006667,  1540401457157816883,
    342666797974407771,   983493939256405289,   771890739233563630,
    553508169276984534,   1589643033626739902,  2263336780810576844,
    330722743541775969,   688712796851212633,   1742668713148160305,
    1245320973785726531,  2208596672445898769,  1422777727841816361,
    152919646732699457,   826464124477841459,   4460107693596700864,
    3530055095011467256,  2403999925630162832,  2899137386794791138,
    3398970977768160805,  2464498338584432925,  3716128830812494197,
    4248337413163712007,  4264326372183459627,  3906261395711551507,
    2851952150714671227,  3383149429014333193,  2386233046276708699,
    3172117876357805667,  4441779805226941963,  3801926588820052345,
    170684860043692426,   1100671402695403186,  2226926226858061530,
    1693589575942097320,  1193606390847620975,  2128144916583147607,
    876319371625685055,   382305650241144653,   1102545060664966090,
    168107437338776818,   1437989166537956506,  1915072878734195688,
    1548519783094789562,  1757891215679916674,  703889661060612842,
    46092416782165400,    3908715595921208683,  4262294307145226835,
    3064498623987880507,  2585134797421409609,  2661735585529691022,
    3019760716990469302,  4055956603131813086,  3543998858204232620,
    5317339067591416425,  4959238909506745681,  6157334207435046201,
    6635009461133220427,  6051307208490845209,  6837227221258447649,
    5711490920986878793,  5054232433096901691,  8122648135453742280,
    9052599496358476784,  7782418148093113240,  7307023562816214250,
    7095314801322056237,  8029818144085865749,  9137340041034366333,
    8622472983995947535,  7806751516869674914,  7011855109925922970,
    8137690373747335410,  8757695200062998400,  8531879593853721042,
    8898947385530005226,  7700757522090507906,  7186022138009770480,
    6135219772853324035,  6358123720871388731,  5304510851123850835,
    4682089562405882145,  5182028715320330214,  5400512630465816798,
    6580751683450298550,  5923625422568720324,  13124074928584983660,
    13491146941631638356, 12293650504952193852, 11816502978180760654,
    12399079312662682140, 11604187204414436644, 12730450818222161228,
    13388307479092468286, 10327209524901530317, 9388215691182564853,
    10657868830410829213, 11137168911054473967, 11357920004770333736,
    10414374197647485712, 9306325182584103800,  9818342344138146826,
    9386341947321596045,  10329786896059045813, 11455812913355464669,
    10924692575052363951, 10984992149858150141, 10766613702172592581,
    9568826821541020077,  10208598699842184927, 13488692655530571308,
    13126106942075820308, 12072096584926548348, 12605510244625659406,
    12249677498819492041, 11882645355480553457, 13062230760632229785,
    13556163143878539499, 14178740190036597038, 14545847390080448022,
    15599559227675164286, 15067834145139579148, 16065876409530435422,
    15270949115358734438, 14000758968863088654, 14640014089599289212,
    18281953465151117199, 17342994818563569847, 16217267316526477535,
    16746698532205467565, 17255653680509032810, 16312143059561297490,
    17564497017566543418, 18061360711745100104, 16237972021990524133,
    17023861349393640413, 18293930539975648181, 17619893477009409223,
    18115916316835994261, 17757855915011241389, 16704251839199542725,
    17200966263939144375, 15576639675766950468, 15362743113290245500,
    14164544455910714644, 14841019967217601126, 14620295210399335585,
    14410818688327658393, 15446357621659116529, 16085462927495578755,
    18237799192036655099, 17294270664133710019, 16258109964509321387,
    16773410497518403545, 16657084189963477387, 16875519862962278067,
    18127020052323321563, 17507580374969491881, 14153168177888129370,
    14515696771658964578, 15624080140268688906, 15110866744451150200,
    15466708232756051903, 15833797605570023559, 14563810316809509103,
    14085706539145691037, 14517711175708869402, 14150731501263563810,
    15402451490950456394, 15899948742203982648, 15224753927964908906,
    16019597712369578578, 14983744703118572090, 14310050713553640776,
    17296865610423782843, 18235907873078829699, 17055988043521714923,
    16561000163437350297, 16340222631939670878, 17283720110790814822,
    18338064546595415054, 17805706452459078524, 10375933128878629561,
    9432369415202180481,  10612588863825479145, 11105888166746317467,
    10794790039591648457, 11013260899437695985, 9905396050428550041,
    9228014311730625771,  13154226096333843480, 13516719503928509216,
    12264699899470662472, 11768891770841246778, 11836546934201131773,
    12203601119882644933, 13328994472388527533, 12798507759874630367,
    12277767672444305266, 12068343612890878026, 13176021535246260258,
    13816435502572994384, 12705517425460601090, 13640043170446921274,
    12460006250421962322, 11929369723008524576, 10597232027372843475,
    11387585128312430315, 10351852510211364483, 9713802769929286129,
    9357917249443839798,  10143859113470169102, 11342251114164164710,
    10664720106027613972,
];

//==============================================================================
// ASCII → nucleotide index and reverse‑complement index tables.
//==============================================================================

const XX: u8 = 255;

/// ASCII → nucleotide index (A=0, C=1, G=2, T=3, others=255).
pub const CONVERT_TAB: [u8; ASCII_SIZE] = {
    let mut t = [XX; ASCII_SIZE];
    t[b'A' as usize] = 0; t[b'a' as usize] = 0;
    t[b'C' as usize] = 1; t[b'c' as usize] = 1;
    t[b'G' as usize] = 2; t[b'g' as usize] = 2;
    t[b'T' as usize] = 3; t[b't' as usize] = 3;
    t
};

/// ASCII → reverse‑complement index (A→3, C→2, G→1, T→0, others=255).
pub const RC_CONVERT_TAB: [u8; ASCII_SIZE] = {
    let mut t = [XX; ASCII_SIZE];
    t[b'A' as usize] = 3; t[b'a' as usize] = 3;
    t[b'T' as usize] = 0; t[b't' as usize] = 0;
    t[b'C' as usize] = 2; t[b'c' as usize] = 2;
    t[b'G' as usize] = 1; t[b'g' as usize] = 1;
    t
};

/// Build the SEED_TAB mapping ASCII → 64‑bit seed, treating invalid codes
/// as SEED_N (zero).
const fn build_seed_tab() -> [u64; ASCII_SIZE] {
    let mut t = [SEED_N; ASCII_SIZE];
    // Map A, C, G, T (upper/lower) to their seeds
    t[b'A' as usize] = SEED_A; t[b'a' as usize] = SEED_A;
    t[b'C' as usize] = SEED_C; t[b'c' as usize] = SEED_C;
    t[b'G' as usize] = SEED_G; t[b'g' as usize] = SEED_G;
    t[b'T' as usize] = SEED_T; t[b't' as usize] = SEED_T;
    // Also fill in for ASCII & CP_OFF (complements)
    t[1] = SEED_T; // 'A' & 7 = 1 → T
    t[3] = SEED_G; // 'C' & 7 = 3 → G
    t[7] = SEED_C; // 'G' & 7 = 7 → C
    t[4] = SEED_A; // 'T' & 7 = 4 → A
    t
}

/// ASCII → 64‑bit seed lookup table (A/C/G/T/N).
pub const SEED_TAB: [u64; ASCII_SIZE] = build_seed_tab();



File: src/lib.rs
//! # ntHash‑rs
//!
//! An idiomatic, pure‑Rust port of the classic *ntHash* rolling‑hash suite,
//! focused on contiguous k‑mer hashing for DNA sequences.
//!
//! This crate currently provides:
//! - [`kmer::NtHash`]: the canonical contiguous‑k‑mer hasher that skips over
//!   non‑ACGT bases (`N` or other characters).
//!
//! All heavy bit‑twiddling is delegated to low‑level modules (`tables` and
//! `constants`), which mirror the original C++ reference implementation, and
//! helper functionality in `util` for canonicalization and hash extension.
//!
//! ## Example
//!
//! ```rust
//! use nthash_rs::{NtHash, Result};
//!
//! fn main() -> Result<()> {
//!     // Create a new NtHash over "ACGTNACGT", k=4, emit 2 hashes per k‑mer, start at pos=0
//!     let mut hasher = NtHash::new("ACGTNACGT", 4, 2, 0)?;
//!
//!     // First call to roll() initializes and returns true if a valid k‑mer was found
//!     assert!(hasher.roll());
//!     // Retrieve the two hash values for the first valid 4‑mer
//!     let hashes = hasher.hashes();
//!     println!("First k‑mer hashes: {:#x}, {:#x}", hashes[0], hashes[1]);
//!
//!     // Advance through the sequence
//!     while hasher.roll() {
//!         let h = hasher.hashes()[0];
//!         println!("Next k‑mer forward hash: {:#x}", h);
//!     }
//!     Ok(())
//! }
//! ```

// Uncomment to build with `no_std` support
// #![cfg_attr(not(feature = "std"), no_std)]

/// Low‑level random seeds, split‑rotate tables, and numeric constants.
// Not re‑exported directly.
mod constants;
mod tables;
mod util;

/// High‑level contiguous k‑mer rolling hasher.
/// Skips over non‑ACGT bases exactly as the original reference.
pub mod kmer;

// ──────────────────────────────────────────────────────────────
// Re‑exports: public API surface
// --------------------------------------------------------------------------

/// One‑bit split‑rotate left (33 + 31 halves).
pub use tables::srol;
/// Arbitrary split‑rotate via lookup tables.
pub use tables::srol_table;
/// One‑bit split‑rotate right (33 + 31 halves).
pub use tables::sror;

/// Combine forward and reverse hashes into a strand‑independent value.
pub use util::canonical;
/// Derive multiple hash values from a single canonical hash.
pub use util::extend_hashes;

/// Primary rolling k‑mer hasher.
///
/// See [`kmer::NtHash`] for full documentation.
pub use kmer::NtHash;

pub use kmer::NtHashBuilder;

// ──────────────────────────────────────────────────────────────
// Crate‑wide result and error types
// --------------------------------------------------------------------------

/// Shorthand `Result` alias for this crate’s operations.
pub type Result<T, E = NtHashError> = std::result::Result<T, E>;

/// Errors common to all ntHash k‑mer hashers.
#[derive(thiserror::Error, Debug, Clone, PartialEq, Eq)]
pub enum NtHashError {
    /// `k` was zero.
    #[error("k must be > 0")]
    InvalidK,

    /// Provided sequence length is shorter than `k`.
    #[error("sequence length ({seq_len}) < k ({k})")]
    SequenceTooShort { seq_len: usize, k: u16 },

    /// Starting `pos` is beyond the last valid window (`seq.len() - k`).
    #[error("position ({pos}) exceeds sequence length ({seq_len})")]
    PositionOutOfRange { pos: usize, seq_len: usize },
}

// ──────────────────────────────────────────────────────────────
// Basic smoke tests
// --------------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn sanity_kmer() {
        // Create hasher over "ACGTACGT", k=4, 1 hash per k‑mer, start at 0
        let mut h = NtHash::new("ACGTACGT", 4, 1, 0).unwrap();
        // First valid k‑mer should be produced
        assert!(h.roll());
        assert_eq!(h.hashes().len(), 1);
    }
}



File: src/kmer.rs
//! Canonical **ntHash** implementation for *contiguous* k‑mers.
//!
//! This module provides a panic‑free, idiomatic Rust port of the C++ `NtHash`
//! class.  It computes rolling hashes over DNA k‑mers (A/C/G/T/N) in **O(1)**
//! time per base (after an initial **O(k)** seed computation), skipping over
//! any windows that contain ‘N’ exactly as the reference does.
//!
//! All heavy bit‑twiddling is delegated to the `tables` (split‑rotate) and
//! `constants` (lookup tables) modules, plus `util::extend_hashes` for
//! generating extra hash values per k‑mer.
//!
//! Additionally, a Rust‑idiomatic **builder + iterator** facade
//! (`NtHashBuilder` / `NtHashIter`) is provided.

use crate::{
    constants::*,
    tables::{srol, srol_n, srol_table, sror},
    util::extend_hashes,
    NtHashError, // unified crate-level error
};

/// Convenient alias for fallible operations in this module.
pub type Result<T> = crate::Result<T>;

/// Rolling k‑mer hasher over a contiguous DNA sequence.
///
/// Mirrors the C++ `NtHash`:
/// - Initialization is deferred until the first valid k‑mer (skips any
///   windows containing `N`).
/// - `roll()` / `roll_back()` advance by one base, handling skips transparently.
/// - Each valid k‑mer emits `num_hashes` values: the canonical hash plus
///   extra mixes.
pub struct NtHash<'a> {
    seq:         &'a [u8],
    k:           u16,
    pos:         usize,
    initialized: bool,
    fwd_hash:    u64,
    rev_hash:    u64,
    hashes:      Vec<u64>,
}

impl<'a> NtHash<'a> {
    /// Create a new `NtHash` starting at `pos`.
    ///
    /// # Arguments
    ///
    /// * `seq` – full DNA sequence (`A,C,G,T,N` recognized; others treated as `N`)
    /// * `k` – k‑mer length (> 0)
    /// * `num_hashes` – how many hash values per k‑mer
    /// * `pos` – starting index
    ///
    /// # Errors
    ///
    /// Returns if `k == 0`, `seq.len() < k`, or `pos` too large.
    pub fn new(seq: &'a str, k: u16, num_hashes: u8, pos: usize) -> Result<Self> {
        if k == 0 {
            return Err(NtHashError::InvalidK);
        }
        let len = seq.len();
        let k_usz = k as usize;
        if len < k_usz {
            return Err(NtHashError::SequenceTooShort { seq_len: len, k });
        }
        if pos > len - k_usz {
            return Err(NtHashError::PositionOutOfRange { pos, seq_len: len });
        }
        Ok(Self {
            seq: seq.as_bytes(),
            k,
            pos,
            initialized: false,
            fwd_hash: 0,
            rev_hash: 0,
            hashes: vec![0; num_hashes as usize],
        })
    }

    /// Advance forward by one base, skipping over k‑mers with `N`.
    /// Returns `true` if a new valid hash was produced.
    pub fn roll(&mut self) -> bool {
        if !self.initialized {
            return self.init();
        }
        let k_usz = self.k as usize;
        if self.pos >= self.seq.len() - k_usz {
            return false;
        }
        let incoming = self.seq[self.pos + k_usz];
        if SEED_TAB[incoming as usize] == SEED_N {
            self.pos += k_usz;
            return self.init();
        }
        let outgoing = self.seq[self.pos];
        self.fwd_hash = next_forward_hash(self.fwd_hash, self.k, outgoing, incoming);
        self.rev_hash = next_reverse_hash(self.rev_hash, self.k, outgoing, incoming);
        self.update_hashes();
        self.pos += 1;
        true
    }

    /// Move backward by one base, skipping over k‑mers with `N`.
    pub fn roll_back(&mut self) -> bool {
        if !self.initialized && !self.init() {
            return false;
        }
        if self.pos == 0 {
            return false;
        }
        let incoming = self.seq[self.pos - 1];
        if SEED_TAB[incoming as usize] == SEED_N {
            if self.pos < self.k as usize {
                return false;
            }
            self.pos -= self.k as usize;
            return self.init();
        }
        let outgoing = self.seq[self.pos + self.k as usize - 1];
        self.fwd_hash = prev_forward_hash(self.fwd_hash, self.k, outgoing, incoming);
        self.rev_hash = prev_reverse_hash(self.rev_hash, self.k, outgoing, incoming);
        self.update_hashes();
        self.pos -= 1;
        true
    }

    /// Peek the next k‑mer without mutating self.
    pub fn peek(&mut self) -> bool {
        if self.pos >= self.seq.len() - self.k as usize {
            return false;
        }
        let incoming = self.seq[self.pos + self.k as usize];
        self.peek_char(incoming)
    }

    /// Peek with an explicit incoming byte.
    pub fn peek_char(&mut self, incoming: u8) -> bool {
        if !self.initialized && !self.init() {
            return false;
        }
        if SEED_TAB[incoming as usize] == SEED_N {
            return false;
        }
        let outgoing = self.seq[self.pos];
        let fwd = next_forward_hash(self.fwd_hash, self.k, outgoing, incoming);
        let rev = next_reverse_hash(self.rev_hash, self.k, outgoing, incoming);
        self.fill_hash_buffer(fwd, rev);
        true
    }

    /// Peek the previous k‑mer without mutating self.
    pub fn peek_back(&mut self) -> bool {
        if self.pos == 0 {
            return false;
        }
        let incoming = self.seq[self.pos - 1];
        self.peek_back_char(incoming)
    }

    /// Peek backward with explicit incoming byte.
    pub fn peek_back_char(&mut self, incoming: u8) -> bool {
        if !self.initialized && !self.init() {
            return false;
        }
        if SEED_TAB[incoming as usize] == SEED_N {
            return false;
        }
        let outgoing = self.seq[self.pos + self.k as usize - 1];
        let fwd = prev_forward_hash(self.fwd_hash, self.k, outgoing, incoming);
        let rev = prev_reverse_hash(self.rev_hash, self.k, outgoing, incoming);
        self.fill_hash_buffer(fwd, rev);
        true
    }

    /// Returns the most recent hash buffer.
    #[inline(always)]
    pub fn hashes(&self) -> &[u64] {
        &self.hashes
    }

    /// Returns the current k‑mer start index.
    #[inline(always)]
    pub fn pos(&self) -> usize {
        self.pos
    }

    /// Returns the forward‑strand hash.
    #[inline(always)]
    pub fn forward_hash(&self) -> u64 {
        self.fwd_hash
    }

    /// Returns the reverse‑complement hash.
    #[inline(always)]
    pub fn reverse_hash(&self) -> u64 {
        self.rev_hash
    }

    /// Initialize on the first valid k‑mer.
    fn init(&mut self) -> bool {
        let k_usz = self.k as usize;
        while self.pos <= self.seq.len() - k_usz {
            let mut skip = 0;
            if has_invalid_base(&self.seq[self.pos..], k_usz, &mut skip) {
                self.pos += skip + 1;
                continue;
            }
            self.fwd_hash = base_forward_hash(&self.seq[self.pos..], self.k);
            self.rev_hash = base_reverse_hash(&self.seq[self.pos..], self.k);
            self.update_hashes();
            self.initialized = true;
            return true;
        }
        false
    }

    #[inline(always)]
    fn update_hashes(&mut self) {
        extend_hashes(self.fwd_hash, self.rev_hash, self.k as u32, &mut self.hashes);
    }

    #[inline(always)]
    fn fill_hash_buffer(&mut self, fwd: u64, rev: u64) {
        extend_hashes(fwd, rev, self.k as u32, &mut self.hashes);
    }
}

// ──────────────────────────────────────────────────────────────
// Stateless helpers, matching the C++ reference.
// -------------------------------------------------------------------------

#[inline(always)]
fn has_invalid_base(seq: &[u8], k: usize, pos_n: &mut usize) -> bool {
    if let Some(idx) = seq[..k]
        .iter()
        .rposition(|&c| SEED_TAB[c as usize] == SEED_N)
    {
        *pos_n = idx;
        true
    } else {
        false
    }
}

#[inline]
pub fn base_forward_hash(seq: &[u8], k: u16) -> u64 {
    let k = k as usize;
    let mut h = 0;
    for chunk in seq[..k - k % 4].chunks_exact(4) {
        h = srol_n(h, 4);
        let idx = (CONVERT_TAB[chunk[0] as usize] as usize) * 64
                + (CONVERT_TAB[chunk[1] as usize] as usize) * 16
                + (CONVERT_TAB[chunk[2] as usize] as usize) * 4
                + CONVERT_TAB[chunk[3] as usize] as usize;
        h ^= TETRAMER_TAB[idx];
    }
    match k % 4 {
        3 => {
            h = srol_n(h, 3);
            let idx = (CONVERT_TAB[seq[k-3] as usize] as usize)*16
                    + (CONVERT_TAB[seq[k-2] as usize] as usize)*4
                    + CONVERT_TAB[seq[k-1] as usize] as usize;
            h ^= TRIMER_TAB[idx];
        }
        2 => {
            h = srol_n(h, 2);
            let idx = (CONVERT_TAB[seq[k-2] as usize] as usize)*4
                    + CONVERT_TAB[seq[k-1] as usize] as usize;
            h ^= DIMER_TAB[idx];
        }
        1 => {
            h = srol_n(h, 1);
            h ^= SEED_TAB[seq[k-1] as usize];
        }
        _ => {}
    }
    h
}

#[inline]
pub fn base_reverse_hash(seq: &[u8], k: u16) -> u64 {
    let k = k as usize;
    let mut h = 0;
    match k % 4 {
        3 => {
            let idx = (RC_CONVERT_TAB[seq[k-1] as usize] as usize)*16
                    + (RC_CONVERT_TAB[seq[k-2] as usize] as usize)*4
                    + RC_CONVERT_TAB[seq[k-3] as usize] as usize;
            h ^= TRIMER_TAB[idx];
        }
        2 => {
            let idx = (RC_CONVERT_TAB[seq[k-1] as usize] as usize)*4
                    + RC_CONVERT_TAB[seq[k-2] as usize] as usize;
            h ^= DIMER_TAB[idx];
        }
        1 => {
            h ^= SEED_TAB[(seq[k-1] & CP_OFF) as usize];
        }
        _ => {}
    }
    let mut i = k - k % 4;
    while i >= 4 {
        h = srol_n(h, 4);
        let idx = (RC_CONVERT_TAB[seq[i-1] as usize] as usize)*64
                + (RC_CONVERT_TAB[seq[i-2] as usize] as usize)*16
                + (RC_CONVERT_TAB[seq[i-3] as usize] as usize)*4
                + RC_CONVERT_TAB[seq[i-4] as usize] as usize;
        h ^= TETRAMER_TAB[idx];
        i -= 4;
    }
    h
}

#[inline(always)]
fn next_forward_hash(prev: u64, k: u16, char_out: u8, char_in: u8) -> u64 {
    let mut h = srol(prev);
    h ^= SEED_TAB[char_in as usize];
    h ^= srol_table(char_out, k as u32);
    h
}

#[inline(always)]
fn prev_forward_hash(prev: u64, k: u16, char_out: u8, char_in: u8) -> u64 {
    let mut h = prev ^ srol_table(char_in, k as u32);
    h ^= SEED_TAB[char_out as usize];
    sror(h)
}

#[inline(always)]
fn next_reverse_hash(prev: u64, k: u16, char_out: u8, char_in: u8) -> u64 {
    let mut h = prev ^ srol_table(char_in & CP_OFF, k as u32);
    h ^= SEED_TAB[(char_out & CP_OFF) as usize];
    sror(h)
}

#[inline(always)]
fn prev_reverse_hash(prev: u64, k: u16, char_out: u8, char_in: u8) -> u64 {
    let mut h = srol(prev);
    h ^= SEED_TAB[(char_in & CP_OFF) as usize];
    h ^= srol_table(char_out & CP_OFF, k as u32);
    h
}

// ──────────────────────────────────────────────────────────────
// Builder + Iterator facade
// -------------------------------------------------------------------------

/// Configure and consume a rolling‐hash computation as an iterator.
pub struct NtHashBuilder<'a> {
    seq:         &'a str,
    k:           u16,
    num_hashes:  u8,
    pos:         usize,
}

impl<'a> NtHashBuilder<'a> {
    /// Begin building over `seq`.
    pub fn new(seq: &'a str) -> Self {
        NtHashBuilder { seq, k: 0, num_hashes: 1, pos: 0 }
    }

    /// Set the k‑mer length.
    pub fn k(mut self, k: u16) -> Self {
        self.k = k;
        self
    }

    /// Set how many hashes per k‑mer.
    pub fn num_hashes(mut self, m: u8) -> Self {
        self.num_hashes = m;
        self
    }

    /// Set the starting position.
    pub fn pos(mut self, pos: usize) -> Self {
        self.pos = pos;
        self
    }

    /// Finalize into an iterator.
    pub fn finish(self) -> Result<NtHashIter<'a>> {
        let hasher = NtHash::new(self.seq, self.k, self.num_hashes, self.pos)?;
        Ok(NtHashIter { hasher, done: false })
    }
}

/// Iterator yielding `(pos, Vec<u64>)` for each valid k‑mer.
pub struct NtHashIter<'a> {
    hasher: NtHash<'a>,
    done:   bool,
}

impl<'a> Iterator for NtHashIter<'a> {
    type Item = (usize, Vec<u64>);

    fn next(&mut self) -> Option<Self::Item> {
        if self.done {
            return None;
        }
        if !self.hasher.roll() {
            self.done = true;
            return None;
        }
        let pos = self.hasher.pos();
        let hashes = self.hasher.hashes().to_vec();
        Some((pos, hashes))
    }
}

impl<'a> IntoIterator for NtHashBuilder<'a> {
    type Item = (usize, Vec<u64>);
    type IntoIter = NtHashIter<'a>;

    fn into_iter(self) -> Self::IntoIter {
        self.finish().expect("invalid NtHashBuilder configuration")
    }
}



File: src/tables.rs
//! Low‑level **split‑rotate** primitives for ntHash.
//!
//! This module implements the core bit‑twiddling operations used by all
//! ntHash variants.  The **split‑rotate** (`srol` / `sror`) operations rotate
//! a 64‑bit word in two independent halves (33 bits + 31 bits) to preserve
//! strand‑symmetry properties.  We also provide a lookup‑based variant
//! (`srol_table`) that applies a split‑rotate to a pre‑seeded constant
//! (A/C/G/T/N) and supports arbitrary rotation distances without branches.
//!
//! All functions are marked `#[inline(always)]` for maximum performance — each
//! compiles down to a handful of shifts, masks, and table lookups.

use crate::constants::{MS_TAB_31L, MS_TAB_33R};

/// One‑bit split‑rotate left (33 + 31 bit halves).
///
/// Conceptually, the 64‑bit word is split into:
/// - a 33‑bit "upper" half (bits 32–63)
/// - a 31‑bit "lower" half (bits 0–30)
///
/// Each half is rotated left by one bit, exchanging carry bits:
/// - bit 63 ➔ bit 33 (upper ➔ lower)
/// - bit 32 ➔ bit 0  (lower ➔ upper)
///
/// This preserves the strand‑symmetry invariants important to ntHash.
#[inline(always)]
pub const fn srol(x: u64) -> u64 {
    // extract the wrap bits from each half
    let m = ((x & 0x8000_0000_0000_0000) >> 30)   // bit 63 ➔ bit 33
          | ((x & 0x0000_0001_0000_0000) >> 32);  // bit 32 ➔ bit 0
    // shift left and re‑insert those bits
    ((x << 1) & 0xFFFF_FFFD_FFFF_FFFF) | m
}

/// Arbitrary‑distance split‑rotate left (0 ≤ d < 64).
///
/// This implements `d` repeated one‑bit split‑rotates efficiently:
/// 1. Perform a full 64‑bit rotate left by `d`.
/// 2. "Unscramble" any bits that crossed the 33/31 boundary to match
///    the effect of split‑rotating each half independently.
#[inline(always)]
pub const fn srol_n(x: u64, d: u32) -> u64 {
    if d == 0 {
        return x;
    }
    // full rotate
    let v = x.rotate_left(d);
    // detect bits that straddle the 33/31 boundary
    let y = (v ^ (v >> 33)) & (!0u64 >> (64 - d));
    // correct their placement
    v ^ (y | (y << 33))
}

/// One‑bit split‑rotate right (33 + 31 bit halves).
///
/// Inverse of [`srol`].  Rotates each half right by one bit, exchanging:
/// - bit 33 ➔ bit 63
/// - bit 0  ➔ bit 32
#[inline(always)]
pub const fn sror(x: u64) -> u64 {
    // extract wrap bits for right rotation
    let m = ((x & 0x0000_0002_0000_0000) << 30)   // bit 33 ➔ bit 63
          | ((x & 0x0000_0000_0000_0001) << 32);  // bit 0  ➔ bit 32
    ((x >> 1) & 0xFFFF_FFFE_FFFF_FFFF) | m
}

/// Lookup‑based split‑rotate left.
///
/// Applies a split‑rotate of distance `d` to the 64‑bit seed constant for
/// nucleotide `c` (A,C,G,T,N).  Internally indexes two pre‑computed tables:
/// - `MS_TAB_31L[c][d % 31]` for the 31‑bit lower half
/// - `MS_TAB_33R[c][d % 33]` for the 33‑bit upper half
///
/// This avoids any runtime loops or branching in the hot path.
#[inline(always)]
pub fn srol_table(c: u8, d: u32) -> u64 {
    let idx31 = (d % 31) as usize;
    let idx33 = (d % 33) as usize;
    MS_TAB_31L[c as usize][idx31] | MS_TAB_33R[c as usize][idx33]
}

#[cfg(test)]
mod tests {
    use super::*;

    /// `srol` followed by `sror` repeatedly should restore the original value.
    #[test]
    fn srol_and_sror_inverse() {
        let mut x = 0xDEADBEEF_DEADBEEF_u64;
        for _ in 0..128 {
            x = srol(x);
            x = sror(x);
        }
        assert_eq!(x, 0xDEADBEEF_DEADBEEF);
    }

    /// `srol_n` should match `d` repeated calls to `srol`.
    #[test]
    fn srol_vs_srol_n() {
        let x = 0x1234_5678_9ABC_DEF0_u64;
        let mut y = x;
        for _ in 0..17 {
            y = srol(y);
        }
        assert_eq!(y, srol_n(x, 17));
    }

    /// `srol_table` must agree with `srol_n` when applied to the base seed.
    #[test]
    fn table_matches_srol_n() {
        let bases = [b'A', b'C', b'G', b'T', b'N'];
        for &b in &bases {
            let seed = srol_table(b, 0);
            for d in 0..64u32 {
                assert_eq!(srol_table(b, d), srol_n(seed, d));
            }
        }
    }
}



